package main

import "fmt"

// MobileAlertStater обеспечивает общий интерфейс для различных состояний.
type MobileAlertStater interface {
	Alert() string
}

// MobileAlert реализует оповещение в зависимости от своего состояния.
type MobileAlert struct {
	state MobileAlertStater
}

// Alert возвращает строку
func (a *MobileAlert) Alert() string {
	return a.state.Alert()
}

// SetState изменяет состояние
func (a *MobileAlert) SetState(state MobileAlertStater) {
	a.state = state
}

// NewMobileAlert это конструктор MobileAlert.
func NewMobileAlert() *MobileAlert {
	return &MobileAlert{state: &MobileAlertVibration{}}
}

// MobileAlertVibration реализует вибрации
type MobileAlertVibration struct {
}

// Alert возвращает вибрации предупреждения
func (a *MobileAlertVibration) Alert() string {
	return "Vrrr... Brrr... Vrrr..."
}

// MobileAlertSong реализует звуковой сигнал
type MobileAlertSong struct {
}

// Alert возвращает звуковое предупреждения
func (a *MobileAlertSong) Alert() string {
	return "Белые розы, Белые розы. Беззащитны шипы..."
}

/**
Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния.
Извне создаётся впечатление, что изменился класс объекта

Идея в том, что программа может находиться в одном из нескольких состояний,
которые всё время сменяют друг друга. Набор этих состояний, а также переходов между ними, предопределён и конечен.
Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней

Нужен:
	Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.
	(Паттерн предлагает выделить в собственные классы все поля и методы, связанные с определёнными состояниями)

	Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса.
	(Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс.)

++ Плюсы
1. Избавляет от множества больших условных операторов
2. Концентрирует в одном месте код, связанный с определённым состоянием

-- Минусы
1. Может неоправданно усложнить код, если состояний мало и они редко меняются
 */

func main()  {
	/**
	1. Создаем интерфейс и описываем методы
	2. Создаем объекты с одним конкретным состоянием, описываем его в методе интерфейса
	3. Создаем объект, который изменяет свое состояние и добавляем сетер который будет принимать интерфейс состояний, который и будет изменять его состояние
	4. Объект также должен реализовать интерфейс состояния, в котором будет вызывать метод конкретного состояния
	 */
	s := &MobileAlertSong{}
	ma := NewMobileAlert()

	// Вызываем оповещение телефона (по умолчанию вибрация)
	fmt.Println(ma.Alert())

	// Меняем состояние на звук
	ma.SetState(s)
	fmt.Println(ma.Alert())
}
